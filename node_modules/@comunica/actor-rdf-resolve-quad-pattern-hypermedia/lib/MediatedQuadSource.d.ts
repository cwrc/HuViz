import { IActionRdfDereferencePaged, IActorRdfDereferencePagedOutput } from "@comunica/bus-rdf-dereference-paged";
import { ILazyQuadSource } from "@comunica/bus-rdf-resolve-quad-pattern";
import { ActionContext, Actor, IActorTest, Mediator } from "@comunica/core";
import { AsyncIterator } from "asynciterator";
import * as RDF from "rdf-js";
/**
 * A QPF quad source that uses a paged RDF dereference mediator
 * and a quad pattern to URL constructor
 * to acts as an RDFJS source.
 *
 * @see RDF.Source
 */
export declare class MediatedQuadSource implements ILazyQuadSource {
    readonly mediatorRdfDereferencePaged: Mediator<Actor<IActionRdfDereferencePaged, IActorTest, IActorRdfDereferencePagedOutput>, IActionRdfDereferencePaged, IActorTest, IActorRdfDereferencePagedOutput>;
    readonly uriConstructor: ((subject?: RDF.Term, predicate?: RDF.Term, object?: RDF.Term, graph?: RDF.Term) => Promise<string>);
    readonly context: ActionContext;
    constructor(mediatorRdfDereferencePaged: Mediator<Actor<IActionRdfDereferencePaged, IActorTest, IActorRdfDereferencePagedOutput>, IActionRdfDereferencePaged, IActorTest, IActorRdfDereferencePagedOutput>, uriConstructor: ((subject?: RDF.Term, predicate?: RDF.Term, object?: RDF.Term, graph?: RDF.Term) => Promise<string>), context: ActionContext);
    /**
     * Check if the given pattern matches with the given quad.
     * @param {Quad} pattern A quad pattern.
     * @param {Quad} quad A quad.
     * @return {boolean} If they match.
     */
    static matchPattern(pattern: RDF.Quad, quad: RDF.Quad): boolean;
    /**
     * A helper function to find a hash with quad elements that have duplicate variables.
     *
     * @param {RDF.Term} subject An optional subject term.
     * @param {RDF.Term} predicate An optional predicate term.
     * @param {RDF.Term} object An optional object term.
     * @param {RDF.Term} graph An optional graph term.
     *
     * @return {{[p: string]: string[]}} If no equal variable names are present in the four terms, this returns null.
     *                                   Otherwise, this maps quad elements ('subject', 'predicate', 'object', 'graph')
     *                                   to the list of quad elements it shares a variable name with.
     *                                   If no links for a certain element exist, this element will
     *                                   not be included in the hash.
     *                                   Note 1: Quad elements will never have a link to themselves.
     *                                           So this can never occur: { subject: [ 'subject'] },
     *                                           instead 'null' would be returned.
     *                                   Note 2: Links only exist in one direction,
     *                                           this means that { subject: [ 'predicate'], predicate: [ 'subject' ] }
     *                                           will not occur, instead only { subject: [ 'predicate'] }
     *                                           will be returned.
     */
    getDuplicateElementLinks(subject?: RDF.Term, predicate?: RDF.Term, object?: RDF.Term, graph?: RDF.Term): {
        [element: string]: string[];
    };
    matchLazy(subject?: RegExp | RDF.Term, predicate?: RegExp | RDF.Term, object?: RegExp | RDF.Term, graph?: RegExp | RDF.Term): AsyncIterator<RDF.Quad> & RDF.Stream;
    match(subject?: RegExp | RDF.Term, predicate?: RegExp | RDF.Term, object?: RegExp | RDF.Term, graph?: RegExp | RDF.Term): RDF.Stream;
}
