"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DataFactory = require("@rdfjs/data-model");
const asynciterator_promiseproxy_1 = require("asynciterator-promiseproxy");
const rdf_string_1 = require("rdf-string");
const rdf_terms_1 = require("rdf-terms");
/**
 * A QPF quad source that uses a paged RDF dereference mediator
 * and a quad pattern to URL constructor
 * to acts as an RDFJS source.
 *
 * @see RDF.Source
 */
class MediatedQuadSource {
    constructor(mediatorRdfDereferencePaged, uriConstructor, context) {
        this.mediatorRdfDereferencePaged = mediatorRdfDereferencePaged;
        this.uriConstructor = uriConstructor;
        this.context = context;
    }
    /**
     * Check if the given pattern matches with the given quad.
     * @param {Quad} pattern A quad pattern.
     * @param {Quad} quad A quad.
     * @return {boolean} If they match.
     */
    static matchPattern(pattern, quad) {
        for (const termName of rdf_terms_1.QUAD_TERM_NAMES) {
            const patternTerm = pattern[termName];
            if (patternTerm && patternTerm.termType !== 'Variable') {
                const quadTerm = quad[termName];
                if (!patternTerm.equals(quadTerm)) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * A helper function to find a hash with quad elements that have duplicate variables.
     *
     * @param {RDF.Term} subject An optional subject term.
     * @param {RDF.Term} predicate An optional predicate term.
     * @param {RDF.Term} object An optional object term.
     * @param {RDF.Term} graph An optional graph term.
     *
     * @return {{[p: string]: string[]}} If no equal variable names are present in the four terms, this returns null.
     *                                   Otherwise, this maps quad elements ('subject', 'predicate', 'object', 'graph')
     *                                   to the list of quad elements it shares a variable name with.
     *                                   If no links for a certain element exist, this element will
     *                                   not be included in the hash.
     *                                   Note 1: Quad elements will never have a link to themselves.
     *                                           So this can never occur: { subject: [ 'subject'] },
     *                                           instead 'null' would be returned.
     *                                   Note 2: Links only exist in one direction,
     *                                           this means that { subject: [ 'predicate'], predicate: [ 'subject' ] }
     *                                           will not occur, instead only { subject: [ 'predicate'] }
     *                                           will be returned.
     */
    getDuplicateElementLinks(subject, predicate, object, graph) {
        // Collect a variable to quad elements mapping.
        const variableElements = {};
        let duplicateVariables = false;
        const input = { subject, predicate, object, graph };
        for (const key of Object.keys(input)) {
            if (input[key] && input[key].termType === 'Variable') {
                const val = rdf_string_1.termToString(input[key]);
                const length = (variableElements[val] || (variableElements[val] = [])).push(key);
                duplicateVariables = duplicateVariables || length > 1;
            }
        }
        if (!duplicateVariables) {
            return null;
        }
        // Collect quad element to elements with equal variables mapping.
        const duplicateElementLinks = {};
        for (const variable in variableElements) {
            const elements = variableElements[variable];
            const remainingElements = elements.slice(1);
            // Only store the elements that have at least one equal element.
            if (remainingElements.length) {
                duplicateElementLinks[elements[0]] = remainingElements;
            }
        }
        return duplicateElementLinks;
    }
    matchLazy(subject, predicate, object, graph) {
        if (subject instanceof RegExp
            || predicate instanceof RegExp
            || object instanceof RegExp
            || graph instanceof RegExp) {
            throw new Error("MediatedQuadSource does not support matching by regular expressions.");
        }
        const quads = new asynciterator_promiseproxy_1.PromiseProxyIterator(async () => {
            const url = await this.uriConstructor(subject, predicate, object, graph);
            const output = await this.mediatorRdfDereferencePaged.mediate({ context: this.context, url });
            // Emit metadata in the stream, so we can attach it later to the actor's promise output
            quads.emit('metadata', output.firstPageMetadata);
            // The server is free to send any data in its response (such as metadata),
            // including quads that do not match the given matter.
            // Therefore, we have to filter away all non-matching quads here.
            let filteredOutput = output.data.filter(MediatedQuadSource.matchPattern.bind(null, DataFactory.quad(subject, predicate, object, graph || DataFactory.variable('v'))));
            // Detect duplicate variables in the pattern
            const duplicateElementLinks = this
                .getDuplicateElementLinks(subject, predicate, object, graph);
            // If there are duplicate variables in the search pattern,
            // make sure that we filter out the triples that don't have equal values for those triple elements,
            // as QPF ignores variable names.
            if (duplicateElementLinks) {
                filteredOutput = filteredOutput.filter((quad) => {
                    // No need to check the graph, because an equal element already would have to be found in s, p, or o.
                    for (const element1 of rdf_terms_1.TRIPLE_TERM_NAMES) {
                        for (const element2 of (duplicateElementLinks[element1] || [])) {
                            if (!quad[element1].equals(quad[element2])) {
                                return false;
                            }
                        }
                    }
                    return true;
                });
            }
            return filteredOutput;
        });
        quads.on('newListener', (eventName) => {
            if (eventName === 'metadata') {
                setImmediate(() => quads._fillBuffer());
            }
        });
        return quads;
    }
    match(subject, predicate, object, graph) {
        return this.matchLazy(subject, predicate, object, graph);
    }
}
exports.MediatedQuadSource = MediatedQuadSource;
//# sourceMappingURL=MediatedQuadSource.js.map