"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_rdf_resolve_quad_pattern_1 = require("@comunica/bus-rdf-resolve-quad-pattern");
const utils_datasource_1 = require("@comunica/utils-datasource");
const rdf_string_1 = require("rdf-string");
const MediatedQuadSource_1 = require("./MediatedQuadSource");
/**
 * A comunica Hypermedia RDF Resolve Quad Pattern Actor.
 */
class ActorRdfResolveQuadPatternHypermedia extends bus_rdf_resolve_quad_pattern_1.ActorRdfResolveQuadPatternSource {
    constructor(args) {
        super(args);
        this.sources = {};
    }
    async test(action) {
        if (!(await utils_datasource_1.DataSourceUtils.singleSourceHasType(action.context, 'hypermedia'))) {
            throw new Error(`${this.name} requires a single source with a \'hypermedia\' entrypoint to be present in the context.`);
        }
        return true;
    }
    /**
     * Choose a Hypermedia hypermedia form.
     * @param {string} hypermedia A hypermedia URL.
     * @param {ActionContext} context An optional context.
     * @return {Promise<ISearchForm>} A promise resolving to a hypermedia form.
     */
    async chooseForm(hypermedia, context) {
        // Mediate the hypermedia url to get a paged stream
        const firstPageMetadata = (await this.mediatorRdfDereferencePaged
            .mediate({ context, url: hypermedia })).firstPageMetadata;
        if (!firstPageMetadata) {
            throw new Error(`No metadata was found at hypermedia entrypoint ${hypermedia}`);
        }
        const metadata = await firstPageMetadata();
        if (!metadata.searchForms || !metadata.searchForms.values.length) {
            throw new Error(`No Hydra search forms were discovered in the metadata of ${hypermedia}.` +
                ` You may be missing an actor that extracts this metadata`);
        }
        // Mediate the metadata to get the searchform
        const searchForm = (await this.mediatorRdfResolveHypermedia.mediate({ metadata, context })).searchForm;
        return searchForm;
    }
    async createSource(context) {
        // Determine form lazily when a URL is constructed.
        let chosenForm = null;
        // Create a quad pattern to URL converter
        const uriConstructor = async (subject, predicate, object, graph) => {
            if (!chosenForm) {
                // Collect metadata of the hypermedia
                const hypermedia = this.getContextSourceUrl(context);
                // Save the form, so it is determined only once per source.
                chosenForm = this.chooseForm(hypermedia, context);
            }
            const entries = {};
            const input = [
                { uri: this.subjectUri, term: subject },
                { uri: this.predicateUri, term: predicate },
                { uri: this.objectUri, term: object },
                { uri: this.graphUri, term: graph },
            ];
            for (const entry of input) {
                if (entry.uri && entry.term) {
                    entries[entry.uri] = rdf_string_1.termToString(entry.term);
                }
            }
            return (await chosenForm).getUri(entries);
        };
        return new MediatedQuadSource_1.MediatedQuadSource(this.mediatorRdfDereferencePaged, uriConstructor, context);
    }
    async getSource(context) {
        // Cache the source object for each hypermedia entrypoint
        const hypermedia = this.getContextSourceUrl(context);
        if (this.sources[hypermedia]) {
            return this.sources[hypermedia];
        }
        // Cache and return
        return await (this.sources[hypermedia] = this.createSource(context));
    }
    async getOutput(source, pattern, context) {
        // Attach metadata to the output
        const output = await super.getOutput(source, pattern, context);
        output.metadata = () => new Promise((resolve, reject) => {
            output.data.on('error', reject);
            output.data.on('end', () => reject(new Error('No metadata was found')));
            output.data.on('metadata', (metadata) => {
                resolve(metadata());
            });
        });
        return output;
    }
}
exports.ActorRdfResolveQuadPatternHypermedia = ActorRdfResolveQuadPatternHypermedia;
//# sourceMappingURL=ActorRdfResolveQuadPatternHypermedia.js.map