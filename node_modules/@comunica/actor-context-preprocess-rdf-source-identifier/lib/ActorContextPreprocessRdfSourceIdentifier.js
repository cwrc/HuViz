"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_context_preprocess_1 = require("@comunica/bus-context-preprocess");
const bus_rdf_resolve_quad_pattern_1 = require("@comunica/bus-rdf-resolve-quad-pattern");
const asyncreiterable_1 = require("asyncreiterable");
/**
 * A comunica RDF Source Identifier Context Preprocess Actor.
 */
class ActorContextPreprocessRdfSourceIdentifier extends bus_context_preprocess_1.ActorContextPreprocess {
    constructor(args) {
        super(args);
    }
    async test(action) {
        return true;
    }
    async run(action) {
        if (action.context) {
            if (action.context.get(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCE)) {
                let source = action.context.get(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCE);
                let context = action.context;
                if (source.type === 'auto') {
                    context = action.context.delete(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCE);
                    source = await this.identifySource(source, context);
                    context = context.set(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCE, source);
                }
                return { context };
            }
            else if (action.context.get(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCES)) {
                const subContext = action.context.delete(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCES);
                const endSource = () => {
                    if (--remainingSources === 0) {
                        newSources.push(null);
                    }
                };
                const sources = action.context.get(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCES);
                const newSources = asyncreiterable_1.AsyncReiterableArray.fromInitialEmpty();
                const identificationPromises = [];
                let remainingSources = 1;
                const it = sources.iterator();
                it.on('data', (source) => {
                    remainingSources++;
                    if (source.type === 'auto') {
                        identificationPromises.push(this.identifySource(source, subContext)
                            .then((identifiedSource) => {
                            newSources.push(identifiedSource);
                            endSource();
                        }));
                    }
                    else {
                        newSources.push(source);
                        endSource();
                    }
                });
                it.on('end', () => {
                    endSource();
                });
                // If the sources are fixed, block until all sources are transformed.
                if (sources.isEnded()) {
                    await new Promise((resolve) => it.on('end', resolve));
                    await Promise.all(identificationPromises);
                }
                return { context: action.context.set(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCES, newSources) };
            }
        }
        return action;
    }
    async identifySource(source, context) {
        return this.mediatorRdfSourceIdentifier.mediate({ sourceValue: source.value, context })
            .then((sourceIdentificationResult) => {
            if (sourceIdentificationResult.sourceType) {
                source.type = sourceIdentificationResult.sourceType;
            }
            return source;
        });
    }
}
exports.ActorContextPreprocessRdfSourceIdentifier = ActorContextPreprocessRdfSourceIdentifier;
//# sourceMappingURL=ActorContextPreprocessRdfSourceIdentifier.js.map