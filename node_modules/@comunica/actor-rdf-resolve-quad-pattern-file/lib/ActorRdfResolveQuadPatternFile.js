"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_rdf_resolve_quad_pattern_1 = require("@comunica/bus-rdf-resolve-quad-pattern");
const LRUCache = require("lru-cache");
const n3_1 = require("n3");
const N3StoreIterator_1 = require("./N3StoreIterator");
const N3StoreQuadSource_1 = require("./N3StoreQuadSource");
/**
 * A comunica File RDF Resolve Quad Pattern Actor.
 */
class ActorRdfResolveQuadPatternFile extends bus_rdf_resolve_quad_pattern_1.ActorRdfResolveQuadPatternSource {
    constructor(args) {
        super(args);
        this.cache = new LRUCache({ max: this.cacheSize });
        this.httpInvalidator.addInvalidateListener(({ pageUrl }) => pageUrl ? this.cache.del(pageUrl) : this.cache.reset());
    }
    initializeFile(file, context) {
        const storePromise = this.mediatorRdfDereference.mediate({ context, url: file })
            .then((page) => new Promise((resolve, reject) => {
            const store = new n3_1.Store();
            page.quads.on('data', (quad) => store.addQuad(quad));
            page.quads.on('error', reject);
            page.quads.on('end', () => resolve(store));
        }));
        this.cache.set(file, storePromise);
        return storePromise;
    }
    async initialize() {
        (this.files || []).forEach((file) => this.initializeFile(file, null));
        return null;
    }
    async test(action) {
        if (!this.hasContextSingleSource('file', action.context)) {
            throw new Error(this.name + ' requires a single source with a file to be present in the context.');
        }
        return true;
    }
    async getSource(context) {
        const file = this.getContextSourceUrl(context);
        if (!this.cache.has(file)) {
            await this.initializeFile(file, context);
        }
        return new N3StoreQuadSource_1.N3StoreQuadSource(await this.cache.get(file));
    }
    async getOutput(source, pattern, context) {
        // Attach totalItems to the output
        const output = await super.getOutput(source, pattern, context);
        output.metadata = () => new Promise((resolve, reject) => {
            const file = this.getContextSourceUrl(context);
            this.cache.get(file).then((store) => {
                const totalItems = store.countQuads(N3StoreIterator_1.N3StoreIterator.nullifyVariables(pattern.subject), N3StoreIterator_1.N3StoreIterator.nullifyVariables(pattern.predicate), N3StoreIterator_1.N3StoreIterator.nullifyVariables(pattern.object), N3StoreIterator_1.N3StoreIterator.nullifyVariables(pattern.graph));
                resolve({ totalItems });
            }, reject);
        });
        return output;
    }
}
exports.ActorRdfResolveQuadPatternFile = ActorRdfResolveQuadPatternFile;
//# sourceMappingURL=ActorRdfResolveQuadPatternFile.js.map