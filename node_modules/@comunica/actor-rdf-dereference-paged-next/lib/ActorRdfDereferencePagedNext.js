"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_rdf_dereference_paged_1 = require("@comunica/bus-rdf-dereference-paged");
const LRUCache = require("lru-cache");
const MediatedPagedAsyncRdfIterator_1 = require("./MediatedPagedAsyncRdfIterator");
/**
 * An RDF Dereference Paged Actor that will lazily follow 'next' links as defined from the extracted metadata.
 */
class ActorRdfDereferencePagedNext extends bus_rdf_dereference_paged_1.ActorRdfDereferencePaged {
    constructor(args) {
        super(args);
        this.cache = this.cacheSize ? new LRUCache({ max: this.cacheSize }) : null;
        if (this.cache) {
            this.httpInvalidator.addInvalidateListener(({ pageUrl }) => pageUrl ? this.cache.del(pageUrl) : this.cache.reset());
        }
    }
    test(action) {
        // Try to determine an actor in the RDF dereference bus to see if we can handle the given URL.
        return this.mediatorRdfDereference.mediateActor({ context: action.context, url: action.url });
    }
    run(action) {
        if (this.cacheSize && this.cache.has(action.url)) {
            return this.cloneOutput(this.cache.get(action.url));
        }
        const output = this.runAsync(action);
        if (this.cacheSize) {
            this.cache.set(action.url, output);
            return this.cloneOutput(output);
        }
        else {
            return output;
        }
    }
    /**
     * Make a copy of the given output promise.
     * @param {Promise<IActorRdfDereferencePagedOutput>} outputPromise An output promise.
     * @return {Promise<IActorRdfDereferencePagedOutput>} A cloned output promise.
     */
    async cloneOutput(outputPromise) {
        const output = await outputPromise;
        return {
            data: output.data.clone(),
            firstPageMetadata: () => output.firstPageMetadata().then((metadata) => Object.assign({}, metadata)),
            firstPageUrl: output.firstPageUrl,
            triples: output.triples,
        };
    }
    /**
     * Actual logic to produce the paged output.
     * @param {IActionRdfDereferencePaged} action An action.
     * @return {Promise<IActorRdfDereferencePagedOutput>} The output.
     */
    async runAsync(action) {
        const firstPage = await this.mediatorRdfDereference.mediate(action);
        const firstPageUrl = firstPage.pageUrl;
        const firstPageMetaSplit = await this.mediatorMetadata
            .mediate({ context: action.context, pageUrl: firstPageUrl, quads: firstPage.quads, triples: firstPage.triples });
        let materializedFirstPageMetadata = null;
        const firstPageMetadata = () => {
            return materializedFirstPageMetadata || (materializedFirstPageMetadata = this.mediatorMetadataExtract.mediate({ context: action.context, pageUrl: firstPageUrl, metadata: firstPageMetaSplit.metadata })
                .then((output) => output.metadata));
        };
        const data = new MediatedPagedAsyncRdfIterator_1.MediatedPagedAsyncRdfIterator(firstPageUrl, firstPageMetaSplit.data, firstPageMetadata, this.mediatorRdfDereference, this.mediatorMetadata, this.mediatorMetadataExtract, action.context);
        return { firstPageUrl, data, firstPageMetadata, triples: firstPage.triples };
    }
}
exports.ActorRdfDereferencePagedNext = ActorRdfDereferencePagedNext;
//# sourceMappingURL=ActorRdfDereferencePagedNext.js.map