{"version":3,"file":"Evaluator.js","sourceRoot":"","sources":["../../../lib/evaluators/Evaluator.ts"],"names":[],"mappings":";;AAKA,sDAAqD;AAGrD,iFAAiG;AAKjG,MAAa,SAAS;IAKpB,YAAmB,OAAuB,EAAS,QAAe,EAAE;QAAjD,YAAO,GAAP,OAAO,CAAgB;QAAS,UAAK,GAAL,KAAK,CAAY;QAClE,IAAI,CAAC,IAAI,GAAG,iCAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QAC7C,IAAI,CAAC,SAAS,GAAG,IAAI,sDAAuB,EAAE,CAAC;QAC/C,IAAI,CAAC,aAAa,GAAG,IAAI,qDAAsB,EAAE,CAAC;IACpD,CAAC;IAED,6EAA6E;IAE7E,KAAK,CAAC,QAAQ,CAAC,OAAiB;QAC9B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjE,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,CAAC;IAC7B,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,OAAiB;QACnC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjE,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC,SAAS,EAAE,CAAC;IACjC,CAAC;IAED,KAAK,CAAC,kBAAkB,CAAC,OAAiB;QACxC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjE,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC;IACrB,CAAC;IAED,6EAA6E;IAE7E,YAAY,CAAC,OAAiB;QAC5B,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC/D,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,CAAC;IAC7B,CAAC;IAED,iBAAiB,CAAC,OAAiB;QACjC,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC/D,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC,SAAS,EAAE,CAAC;IACjC,CAAC;IAED,sBAAsB,CAAC,OAAiB;QACtC,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC/D,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC;IACrB,CAAC;CACF;AA5CD,8BA4CC;AAED,SAAS,GAAG,CAAI,GAAM;IACpB,oBAAoB;IACpB,OAAO,GAAG,CAAC;AACb,CAAC","sourcesContent":["import * as RDF from 'rdf-js';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport * as E from '../expressions/Expressions';\n\nimport { transformAlgebra } from '../Transformation';\nimport { Bindings, ExpressionEvaluator, Hooks } from '../Types';\n\nimport { AsyncRecursiveEvaluator, SyncRecursiveEvaluator } from './RecursiveExpressionEvaluator';\n\ntype Expression = E.Expression;\ntype Term = E.TermExpression;\n\nexport class Evaluator {\n  private expr: Expression;\n  private evaluator: ExpressionEvaluator<Expression, Promise<Term>>;\n  private evaluatorSync: ExpressionEvaluator<Expression, Term>;\n\n  constructor(public algExpr: Alg.Expression, public hooks: Hooks = {}) {\n    this.expr = transformAlgebra(algExpr, hooks);\n    this.evaluator = new AsyncRecursiveEvaluator();\n    this.evaluatorSync = new SyncRecursiveEvaluator();\n  }\n\n  // Async API ----------------------------------------------------------------\n\n  async evaluate(mapping: Bindings): Promise<RDF.Term> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return log(result).toRDF();\n  }\n\n  async evaluateAsEBV(mapping: Bindings): Promise<boolean> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return log(result).coerceEBV();\n  }\n\n  async evaluateAsInternal(mapping: Bindings): Promise<Term> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return log(result);\n  }\n\n  // Sync API -----------------------------------------------------------------\n\n  evaluateSync(mapping: Bindings): RDF.Term {\n    const result = this.evaluatorSync.evaluate(this.expr, mapping);\n    return log(result).toRDF();\n  }\n\n  evaluateAsEBVSync(mapping: Bindings): boolean {\n    const result = this.evaluatorSync.evaluate(this.expr, mapping);\n    return log(result).coerceEBV();\n  }\n\n  evaluateAsInternalSync(mapping: Bindings): Term {\n    const result = this.evaluatorSync.evaluate(this.expr, mapping);\n    return log(result);\n  }\n}\n\nfunction log<T>(val: T): T {\n  // console.log(val);\n  return val;\n}\n"]}