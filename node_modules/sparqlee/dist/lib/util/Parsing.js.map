{"version":3,"file":"Parsing.js","sourceRoot":"","sources":["../../../lib/util/Parsing.ts"],"names":[],"mappings":";AAAA,gCAAgC;;AAEhC;;;;;;;GAOG;AACH,SAAgB,aAAa,CAAC,KAAa;IACzC,MAAM,IAAI,GAAW,MAAM,CAAC,KAAK,CAAC,CAAC;IACnC,IAAI,KAAK,CAAC,IAAI,CAAC,EAAE;QACf,IAAI,KAAK,KAAK,KAAK,EAAE;YAAE,OAAO,GAAG,CAAC;SAAE;QACpC,IAAI,KAAK,KAAK,KAAK,EAAE;YAAE,OAAO,QAAQ,CAAC;SAAE;QACzC,IAAI,KAAK,KAAK,MAAM,EAAE;YAAE,OAAO,CAAC,QAAQ,CAAC;SAAE;QAC3C,OAAO,SAAS,CAAC;KAClB;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AATD,sCASC;AAED;;;;;;;GAOG;AACH,SAAgB,eAAe,CAAC,KAAa;IAC3C,IAAI,+BAA+B,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;QAC/C,MAAM,IAAI,GAAW,MAAM,CAAC,KAAK,CAAC,CAAC;QACnC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC;KACzC;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AAND,0CAMC;AAED;;;;;;;GAOG;AACH,SAAgB,eAAe,CAAC,KAAa;IAC3C,IAAI,oBAAoB,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;QACpC,MAAM,IAAI,GAAW,MAAM,CAAC,KAAK,CAAC,CAAC;QACnC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC;KACzC;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AAND,0CAMC;AAYD;;;;;;;;;;;GAWG;AACH,SAAgB,gBAAgB,CAAC,KAAa;IAC5C,MAAM,CAAC,IAAI,EAAE,eAAe,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACjD,MAAM,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAC3C,MAAM,CAAC,IAAI,EAAE,gBAAgB,CAAC,GAAG,eAAe,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IAClE,MAAM,CAAC,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAClD,MAAM,cAAc,GAAG,IAAI,MAAM,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;IACvE,MAAM,QAAQ,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IAC3D,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC;AACjE,CAAC;AARD,4CAQC","sourcesContent":["// TODO: Find a library for this\n\n/**\n * TODO: Fix decently\n * Parses float datatypes (double, float).\n *\n * All invalid lexical values return undefined.\n *\n * @param value the string to interpret as a number\n */\nexport function parseXSDFloat(value: string): number | undefined {\n  const numb: number = Number(value);\n  if (isNaN(numb)) {\n    if (value === 'NaN') { return NaN; }\n    if (value === 'INF') { return Infinity; }\n    if (value === '-INF') { return -Infinity; }\n    return undefined;\n  }\n  return numb;\n}\n\n/**\n * Parses decimal datatypes (decimal, int, byte, nonPositiveInteger, etc...).\n *\n * All other values, including NaN, INF, and floating point numbers all\n * return undefined;\n *\n * @param value the string to interpret as a number\n */\nexport function parseXSDDecimal(value: string): number | undefined {\n  if (/^(\\-|\\+)?([0-9]+(\\.[0-9]+)?)$/.test(value)) {\n    const numb: number = Number(value);\n    return (isNaN(numb)) ? undefined : numb;\n  }\n  return undefined;\n}\n\n/**\n * Parses integer datatypes (decimal, int, byte, nonPositiveInteger, etc...).\n *\n * All other values, including NaN, INF, and floating point numbers all\n * return undefined;\n *\n * @param value the string to interpret as a number\n */\nexport function parseXSDInteger(value: string): number | undefined {\n  if (/^(\\-|\\+)?([0-9]+)$/.test(value)) {\n    const numb: number = Number(value);\n    return (isNaN(numb)) ? undefined : numb;\n  }\n  return undefined;\n}\n\nexport interface SplittedDate {\n  year: string;\n  month: string;\n  day: string;\n  hours: string;\n  minutes: string;\n  seconds: string;\n  timezone: string;\n}\n\n/**\n * Parses ISO date time strings into it's parts.\n * I found no lib providing this functionality online, but it's needed heavily\n * by the spec (functions on dates), using any form of JS DateTime will lose the\n * original timezone notation.\n *\n * Example strings:\n *  - \"2011-01-10T14:45:13.815-05:00\"\n *  - \"2011-01-10T14:45:13.815Z\"\n *  - \"2011-01-10T14:45:13Z\"\n * @param value the ISO date time string\n */\nexport function parseXSDDateTime(value: string): SplittedDate {\n  const [date, timeAndTimeZone] = value.split('T');\n  const [year, month, day] = date.split('-');\n  const [time, _timeZoneChopped] = timeAndTimeZone.split(/[\\+\\-Z]/);\n  const [hours, minutes, seconds] = time.split(':');\n  const timezoneOrNull = new RegExp(/([\\+\\-Z].*)/).exec(timeAndTimeZone);\n  const timezone = (timezoneOrNull) ? timezoneOrNull[0] : '';\n  return { year, month, day, hours, minutes, seconds, timezone };\n}\n"]}